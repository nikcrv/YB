// Last updated: 2025-11-23 23:38:38 UTC
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YieldBasis - Revenue Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            padding: 40px 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        .header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
        h1 { font-size: 2em; color: #94a3b8; font-weight: 400; flex-grow: 1; text-align: center; margin: 0; }
        .back-button {
            background: #334155;
            border: 1px solid #475569;
            color: #e2e8f0;
            padding: 10px 20px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .back-button:hover {
            background: #475569;
            border-color: #667eea;
            transform: translateX(-2px);
        }
        .back-button::before {
            content: '←';
            font-size: 1.2em;
        }
        .loading { text-align: center; font-size: 1.5em; color: #667eea; padding: 50px; }
        .answer {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            border-radius: 20px; padding: 50px; text-align: center; font-size: 2.5em;
            font-weight: 700; border: 3px solid #10b981; margin-bottom: 60px;
            box-shadow: 0 20px 60px rgba(16, 185, 129, 0.2);
        }
        .answer.negative {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            border-color: #ef4444; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.2);
        }
        .main-metric {
            background: #1e293b; border: 2px solid #334155; border-radius: 16px;
            padding: 40px; margin-bottom: 40px;
        }
        .metric-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 20px 0; border-bottom: 1px solid #334155;
        }
        .metric-row:last-child { border-bottom: none; }
        .metric-label { font-size: 1.1em; color: #94a3b8; }
        .metric-value { font-size: 1.6em; font-weight: 600; color: #e2e8f0; }
        .chart-container {
            background: #1e293b; border: 2px solid #334155; border-radius: 16px;
            padding: 30px; margin-bottom: 40px;
        }
        .chart-wrapper { position: relative; height: 500px; }
        .footer { text-align: center; color: #64748b; padding: 20px; font-size: 0.9em; }
        .chart-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #0f172a;
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .checkbox-group label {
            cursor: pointer;
            color: #94a3b8;
        }
        .success-badge {
            background: #10b981; color: white; padding: 10px 20px;
            border-radius: 8px; display: inline-block; margin-bottom: 20px;
            font-weight: 600;
        }
        .compact-range {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #334155;
        }
        .period-buttons {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            flex-wrap: wrap;
            align-items: center;
        }
        .period-label {
            color: #64748b;
            font-size: 0.85em;
            margin-right: 8px;
        }
        .period-button {
            background: #0f172a;
            color: #94a3b8;
            border: 1px solid #334155;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
        }
        .period-button:hover {
            border-color: #667eea;
            color: #e2e8f0;
        }
        .period-button.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
            font-weight: 500;
        }
        .range-slider {
            width: 100%;
            height: 4px;
            background: #334155;
            border-radius: 2px;
            position: relative;
            margin: 15px 0 8px 0;
        }
        .range-slider input[type="range"] {
            position: absolute;
            width: 100%;
            height: 4px;
            background: transparent;
            pointer-events: none;
            -webkit-appearance: none;
            top: 50%;
            transform: translateY(-50%);
        }
        .range-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: all;
            border: 2px solid #0f172a;
        }
        .range-slider input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: all;
            border: 2px solid #0f172a;
        }
        .range-fill {
            position: absolute;
            height: 4px;
            background: #667eea;
            border-radius: 2px;
            pointer-events: none;
        }
        .range-labels {
            display: flex;
            justify-content: space-between;
            color: #64748b;
            font-size: 0.75em;
        }
    
        /* Contract Version Selector */
        .contract-selector {
            display: flex;
            gap: 10px;
            background: #1e1b4b;
            padding: 6px;
            border-radius: 8px;
            margin-bottom: 15px;
            justify-content: center;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .contract-btn {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: #94a3b8;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95em;
        }

        .contract-btn:hover {
            background: #312e81;
            color: #e2e8f0;
        }

        .contract-btn.active {
            background: #8b5cf6;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="contract-selector">
            <button class="contract-btn active" data-version="new" onclick="switchContractVersion('new')">NEW Contracts</button>
            <button class="contract-btn" data-version="old" onclick="switchContractVersion('old')">OLD Contracts</button>
        </div>

        <div class="loading" id="loading">Loading synchronized data...</div>
        <div id="content" style="display:none;">
            <div class="header">
                <a href="index.html" class="back-button">Back to Vaults</a>
                <h1>YieldBasis Revenue Dashboard</h1>
                <div style="width: 140px;"></div> <!-- Spacer for centering -->
            </div>

            <div class="answer" id="answerBox">
                <span id="finalProfit">0.00000000 BTC</span>
            </div>

            <div class="chart-container">
                <h2 style="color: #94a3b8; font-size: 1.3em; margin-bottom: 20px;">Accumulated Revenue</h2>

                <div class="chart-controls" style="justify-content: space-between;">
                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleWithdrawable" checked>
                            <label for="toggleWithdrawable">TVL</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleDeposits" checked>
                            <label for="toggleDeposits">Deposits</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleWithdrawals" checked>
                            <label for="toggleWithdrawals">Withdrawals</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleAdminFees" checked>
                            <label for="toggleAdminFees">Admin Fees</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleAdminFeeWithdrawals" checked>
                            <label for="toggleAdminFeeWithdrawals">Include Admin Fee Withdrawals</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleYbEmission" checked>
                            <label for="toggleYbEmission">YB Emission</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleFundamental">
                            <label for="toggleFundamental">Show Fundamental Revenue</label>
                        </div>
                    </div>
                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleWbtc" checked>
                            <label for="toggleWbtc">WBTC</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleCbbtc" checked>
                            <label for="toggleCbbtc">cbBTC</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="toggleTbtc" checked>
                            <label for="toggleTbtc">tBTC</label>
                        </div>
                    </div>
                </div>

                <div class="chart-wrapper">
                    <canvas id="profitChart"></canvas>
                </div>

                <div class="compact-range">
                    <div class="period-buttons">
                        <span class="period-label">Period:</span>
                        <button class="period-button" data-days="7">7d</button>
                        <button class="period-button" data-days="14">14d</button>
                        <button class="period-button" data-days="30">30d</button>
                        <button class="period-button active" data-days="all">All</button>
                    </div>
                    <div class="range-slider">
                        <div class="range-fill" id="rangeFill"></div>
                        <input type="range" id="rangeStart" min="0" max="100" value="0">
                        <input type="range" id="rangeEnd" min="0" max="100" value="100">
                    </div>
                    <div class="range-labels">
                        <span id="startLabel">Start</span>
                        <span id="endLabel">End</span>
                    </div>
                </div>
            </div>

            <div class="main-metric" id="metricsBox"></div>

            <div class="chart-container">
                <h2 style="color: #94a3b8; font-size: 1.3em; margin-bottom: 20px;">TVL by Markets</h2>
                <div class="chart-wrapper">
                    <canvas id="tvlByMarketChart"></canvas>
                </div>
            </div>

            <div class="footer" id="footer"></div>
        </div>
    </div>

    <!-- Load SYNCHRONIZED data files -->
    <script src="revenue_yield_wbtc_sync.js?v=6"></script>
    <script src="revenue_yield_cbbtc_sync.js?v=6"></script>
    <script src="revenue_yield_tbtc_sync.js?v=6"></script>
    <script src="yb_emission_data.js?v=6"></script>

    <!-- Load OLD contract data files -->
    <script src="old_revenue_yield_wbtc_sync.js?v=6"></script>
    <script src="old_revenue_yield_cbbtc_sync.js?v=6"></script>
    <script src="old_revenue_yield_tbtc_sync.js?v=6"></script>
    <script src="old_yb_emission_data.js?v=6"></script>

    <!-- Load PPS data files (NEW contracts) -->
    <script src="pps_data_wbtc.js?v=1"></script>
    <script src="pps_data_cbbtc.js?v=1"></script>
    <script src="pps_data_tbtc.js?v=1"></script>

    <!-- Load PPS data files (OLD contracts) -->
    <script src="pps_data_old_wbtc.js?v=1"></script>
    <script src="pps_data_old_cbbtc.js?v=1"></script>
    <script src="pps_data_old_tbtc.js?v=1"></script>

    <!-- Load vaults yield data for trading returns -->
    <script src="vaults_yield_data_wbtc.js"></script>
    <script src="vaults_yield_data_cbbtc.js"></script>
    <script src="vaults_yield_data_tbtc.js"></script>

    <script>
    // Глобальная переменная для текущей версии контракта
    // Загружаем из localStorage или используем 'new' по умолчанию
    let currentContractVersion = localStorage.getItem('contractVersion') || 'new';

    // Функция переключения между NEW и OLD контрактами
    function switchContractVersion(version) {
        // Сохраняем выбор в localStorage
        localStorage.setItem('contractVersion', version);
        currentContractVersion = version;

        // Перезагружаем данные
        location.reload();
    }

    // При загрузке страницы обновляем активную кнопку
    document.addEventListener('DOMContentLoaded', function() {
        document.querySelectorAll('.contract-btn').forEach(btn => {
            btn.classList.remove('active');
            if (btn.getAttribute('data-version') === currentContractVersion) {
                btn.classList.add('active');
            }
        });
    });

    window.addEventListener('load', async function() {
        try {
            console.log('Loading synchronized data...');
            console.log('Contract version:', currentContractVersion);

            // Выбираем источник данных в зависимости от версии контракта
            let yieldDataSource_wbtc, yieldDataSource_cbbtc, yieldDataSource_tbtc, ybEmissionDataSource;

            if (currentContractVersion === 'old') {
                // Проверяем что OLD данные загружены
                if (typeof old_yieldData_wbtc === 'undefined' ||
                    typeof old_yieldData_cbbtc === 'undefined' ||
                    typeof old_yieldData_tbtc === 'undefined') {
                    throw new Error('OLD contract data files not found.');
                }
                yieldDataSource_wbtc = old_yieldData_wbtc;
                yieldDataSource_cbbtc = old_yieldData_cbbtc;
                yieldDataSource_tbtc = old_yieldData_tbtc;
                ybEmissionDataSource = typeof old_ybEmissionData !== 'undefined' ? old_ybEmissionData : null;
            } else {
                // NEW контракты (по умолчанию)
                if (typeof yieldData_wbtc === 'undefined' ||
                    typeof yieldData_cbbtc === 'undefined' ||
                    typeof yieldData_tbtc === 'undefined') {
                    throw new Error('Synchronized data files not found. Run: python collect_sync.py');
                }
                yieldDataSource_wbtc = yieldData_wbtc;
                yieldDataSource_cbbtc = yieldData_cbbtc;
                yieldDataSource_tbtc = yieldData_tbtc;
                ybEmissionDataSource = typeof ybEmissionData !== 'undefined' ? ybEmissionData : null;
            }

            // Данные УЖЕ синхронизированы - просто складываем!
            const wbtcData = yieldDataSource_wbtc.data;
            const cbbtcData = yieldDataSource_cbbtc.data;
            const tbtcData = yieldDataSource_tbtc.data;

            console.log('WBTC points:', wbtcData.length);
            console.log('cbBTC points:', cbbtcData.length);
            console.log('tBTC points:', tbtcData.length);

            // Проверяем синхронизацию
            if (wbtcData.length !== cbbtcData.length || wbtcData.length !== tbtcData.length) {
                throw new Error('Data is not synchronized! Re-run collect_sync.py');
            }

            // Функция для пересчета profit data
            function recalculateProfitData() {
                let cumulativeDeposits = 0;
                let cumulativeWithdrawals = 0;
                let cumulativeAdminFeeWithdrawals = 0;

                return wbtcData.map((wbtc, i) => {
                const cbbtc = cbbtcData[i];
                const tbtc = tbtcData[i];

                // Проверяем что timestamps совпадают
                if (wbtc.timestamp !== cbbtc.timestamp || wbtc.timestamp !== tbtc.timestamp) {
                    console.warn(`Timestamp mismatch at index ${i}`);
                }

                // Складываем данные всех рынков
                const totalWithdrawable = (wbtc.total_withdrawable_btc || 0) +
                                         (cbbtc.total_withdrawable_btc || 0) +
                                         (tbtc.total_withdrawable_btc || 0);

                const deposits = (wbtc.deposits_btc || 0) +
                                (cbbtc.deposits_btc || 0) +
                                (tbtc.deposits_btc || 0);

                const withdrawals = (wbtc.withdrawals_btc || 0) +
                                   (cbbtc.withdrawals_btc || 0) +
                                   (tbtc.withdrawals_btc || 0);

                // Для OLD контрактов используем admin_fees_btc как admin_fee_withdrawals
                // т.к. в OLD контрактах все admin fees фактически были "withdrawn"
                const adminFeeWithdrawals = currentContractVersion === 'old'
                    ? ((wbtc.admin_fees_btc || 0) + (cbbtc.admin_fees_btc || 0) + (tbtc.admin_fees_btc || 0))
                    : ((wbtc.admin_fee_withdrawals_btc || 0) + (cbbtc.admin_fee_withdrawals_btc || 0) + (tbtc.admin_fee_withdrawals_btc || 0));

                const adminFees = (wbtc.admin_fees_btc || 0) +
                                 (cbbtc.admin_fees_btc || 0) +
                                 (tbtc.admin_fees_btc || 0);

                // Накапливаем
                cumulativeDeposits += deposits;
                cumulativeWithdrawals += withdrawals;
                cumulativeAdminFeeWithdrawals += adminFeeWithdrawals;

                // Добавляем admin fee withdrawals к withdrawals если checkbox активен
                const includeAdminFeeWithdrawals = document.getElementById('toggleAdminFeeWithdrawals')?.checked ?? true;
                const effectiveWithdrawals = includeAdminFeeWithdrawals
                    ? cumulativeWithdrawals + cumulativeAdminFeeWithdrawals
                    : cumulativeWithdrawals;

                // Вычисляем прибыль
                // Если включен checkbox, компенсируем уменьшение adminFees добавлением выведенной суммы
                const effectiveAdminFees = includeAdminFeeWithdrawals
                    ? adminFees + cumulativeAdminFeeWithdrawals
                    : adminFees;
                const netDeposited = cumulativeDeposits - effectiveWithdrawals;
                const profit = totalWithdrawable - netDeposited + effectiveAdminFees;

                return {
                    timestamp: wbtc.timestamp,
                    date: new Date(wbtc.timestamp * 1000).toLocaleDateString('en-US'),
                    profit: profit,
                    withdrawable: totalWithdrawable,
                    deposits: cumulativeDeposits,
                    withdrawals: effectiveWithdrawals,
                    admin_fees: adminFees,
                    admin_fee_withdrawals: cumulativeAdminFeeWithdrawals
                };
                });
            }

            // Вызываем функцию для первоначального расчета
            let profitData = recalculateProfitData();

            console.log('Profit data points:', profitData.length);

            // Обновляем метрики
            const lastPoint = profitData[profitData.length - 1];
            const finalProfit = lastPoint.profit;
            const finalTVL = lastPoint.withdrawable;  // TVL для расчета процентов

            document.getElementById('finalProfit').textContent = finalProfit.toFixed(8) + ' BTC';
            document.getElementById('answerBox').className = 'answer';  // Всегда зеленый

            // Вычисляем YB emission для метрик (будет обновлено после загрузки данных)
            let totalYbEmissionBtc = 0;

            const metricsHTML = `
                <div class="metric-row">
                    <div class="metric-label">TVL (Withdrawable)</div>
                    <div class="metric-value">${lastPoint.withdrawable.toFixed(2)} BTC</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">Total Deposits</div>
                    <div class="metric-value">${lastPoint.deposits.toFixed(2)} BTC</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">Total Withdrawals</div>
                    <div class="metric-value">${lastPoint.withdrawals.toFixed(2)} BTC</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">Net Deposited</div>
                    <div class="metric-value">${(lastPoint.deposits - lastPoint.withdrawals).toFixed(2)} BTC</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">Admin Fees</div>
                    <div class="metric-value">${lastPoint.admin_fees.toFixed(4)} BTC</div>
                </div>
                <div class="metric-row">
                    <div class="metric-label">Admin Fee Withdrawals</div>
                    <div class="metric-value">${lastPoint.admin_fee_withdrawals.toFixed(4)} BTC</div>
                </div>
                <div class="metric-row" id="ybEmissionMetric" style="display:none;">
                    <div class="metric-label">YB Emission</div>
                    <div class="metric-value" id="ybEmissionValue">0.0000 BTC</div>
                </div>
            `;
            document.getElementById('metricsBox').innerHTML = metricsHTML;

            // Footer
            const startDate = new Date(profitData[0].timestamp * 1000).toLocaleDateString('en-US');
            const endDate = new Date(profitData[profitData.length - 1].timestamp * 1000).toLocaleDateString('en-US');
            document.getElementById('footer').textContent =
                `Synchronized data | Points: ${profitData.length} | Period: ${startDate} - ${endDate}`;

            // Загрузка данных YB emission (из JS файла для решения CORS проблемы)
            let ybEmissionDataArray = null;
            try {
                if (ybEmissionDataSource) {
                    ybEmissionDataArray = ybEmissionDataSource;
                    console.log('YB emission data loaded:', ybEmissionDataArray.length, 'points');
                } else {
                    console.log('YB emission data not available');
                }
            } catch (error) {
                console.log('YB emission data not available:', error.message);
            }

            // Подготовка данных YB emission для суммирования с интерполяцией (по рынкам)
            if (ybEmissionDataArray) {
                // Фильтруем записи без BTC полей (неполные записи)
                const validYbData = ybEmissionDataArray.filter(item => 
                    item.cumulative_WBTC_btc !== undefined &&
                    item.cumulative_cbBTC_btc !== undefined &&
                    item.cumulative_tBTC_btc !== undefined
                );

                // Создаем массивы с данными для каждого рынка (hourly данные - используем timestamp напрямую)
                const ybDatesWbtc = validYbData.map(item => ({
                    timestamp: item.timestamp,  // Используем timestamp напрямую (hourly данные)
                    value: item.cumulative_WBTC_btc || 0
                })).sort((a, b) => a.timestamp - b.timestamp);

                const ybDatesCbbtc = validYbData.map(item => ({
                    timestamp: item.timestamp,
                    value: item.cumulative_cbBTC_btc || 0
                })).sort((a, b) => a.timestamp - b.timestamp);

                const ybDatesTbtc = validYbData.map(item => ({
                    timestamp: item.timestamp,
                    value: item.cumulative_tBTC_btc || 0
                })).sort((a, b) => a.timestamp - b.timestamp);

                console.log('YB emission по рынкам будет интерполироваться и суммироваться');

                // Функция линейной интерполяции для конкретного рынка
                function interpolateYbEmission(timestamp, ybDates) {
                    if (ybDates.length === 0) return 0;

                    // Если раньше первой даты - возвращаем 0
                    if (timestamp < ybDates[0].timestamp) return 0;

                    // Если позже последней даты - возвращаем последнее значение
                    if (timestamp >= ybDates[ybDates.length - 1].timestamp) {
                        return ybDates[ybDates.length - 1].value;
                    }

                    // Находим ближайшие точки
                    for (let i = 0; i < ybDates.length - 1; i++) {
                        if (timestamp >= ybDates[i].timestamp && timestamp < ybDates[i + 1].timestamp) {
                            const lower = ybDates[i];
                            const upper = ybDates[i + 1];

                            // Линейная интерполяция
                            const ratio = (timestamp - lower.timestamp) / (upper.timestamp - lower.timestamp);
                            return lower.value + ratio * (upper.value - lower.value);
                        }
                    }

                    return 0;
                }

                // Добавляем YB emission к каждой точке profitData с интерполяцией (по рынкам)
                profitData.forEach(point => {
                    point.yb_emission_wbtc_btc = interpolateYbEmission(point.timestamp, ybDatesWbtc);
                    point.yb_emission_cbbtc_btc = interpolateYbEmission(point.timestamp, ybDatesCbbtc);
                    point.yb_emission_tbtc_btc = interpolateYbEmission(point.timestamp, ybDatesTbtc);
                });

                // Обновляем метрику YB emission
                const lastPointIndex = profitData.length - 1;
                const totalYbEmission = (profitData[lastPointIndex].yb_emission_wbtc_btc || 0) +
                                       (profitData[lastPointIndex].yb_emission_cbbtc_btc || 0) +
                                       (profitData[lastPointIndex].yb_emission_tbtc_btc || 0);

                document.getElementById('ybEmissionMetric').style.display = 'flex';
                document.getElementById('ybEmissionValue').textContent = totalYbEmission.toFixed(4) + ' BTC';
            } else {
                profitData.forEach(point => {
                    point.yb_emission_wbtc_btc = 0;
                    point.yb_emission_cbbtc_btc = 0;
                    point.yb_emission_tbtc_btc = 0;
                });
            }

            // ====== PPS DATA & FUNDAMENTAL REVENUE CALCULATION ======

            // Выбираем источник PPS данных в зависимости от версии контракта
            let ppsDataSource_wbtc, ppsDataSource_cbbtc, ppsDataSource_tbtc;

            if (currentContractVersion === 'old') {
                ppsDataSource_wbtc = typeof ppsData_old_wbtc !== 'undefined' ? ppsData_old_wbtc : null;
                ppsDataSource_cbbtc = typeof ppsData_old_cbbtc !== 'undefined' ? ppsData_old_cbbtc : null;
                ppsDataSource_tbtc = typeof ppsData_old_tbtc !== 'undefined' ? ppsData_old_tbtc : null;
            } else {
                ppsDataSource_wbtc = typeof ppsData_wbtc !== 'undefined' ? ppsData_wbtc : null;
                ppsDataSource_cbbtc = typeof ppsData_cbbtc !== 'undefined' ? ppsData_cbbtc : null;
                ppsDataSource_tbtc = typeof ppsData_tbtc !== 'undefined' ? ppsData_tbtc : null;
            }

            // Функция линейной интерполяции PPS для конкретного рынка
            function interpolatePPS(timestamp, ppsDataArray) {
                if (!ppsDataArray || ppsDataArray.length === 0) return { pps_unstaked: 1.0, pps_staked: 1.0 };

                // Если раньше первой даты - возвращаем первое значение
                if (timestamp <= ppsDataArray[0].timestamp) {
                    return {
                        pps_unstaked: ppsDataArray[0].pps_unstaked,
                        pps_staked: ppsDataArray[0].pps_staked
                    };
                }

                // Если позже последней даты - возвращаем последнее значение
                if (timestamp >= ppsDataArray[ppsDataArray.length - 1].timestamp) {
                    const last = ppsDataArray[ppsDataArray.length - 1];
                    return {
                        pps_unstaked: last.pps_unstaked,
                        pps_staked: last.pps_staked
                    };
                }

                // Находим ближайшие точки для интерполяции
                for (let i = 0; i < ppsDataArray.length - 1; i++) {
                    if (timestamp >= ppsDataArray[i].timestamp && timestamp < ppsDataArray[i + 1].timestamp) {
                        const lower = ppsDataArray[i];
                        const upper = ppsDataArray[i + 1];

                        // Линейная интерполяция
                        const ratio = (timestamp - lower.timestamp) / (upper.timestamp - lower.timestamp);
                        return {
                            pps_unstaked: lower.pps_unstaked + ratio * (upper.pps_unstaked - lower.pps_unstaked),
                            pps_staked: lower.pps_staked + ratio * (upper.pps_staked - lower.pps_staked)
                        };
                    }
                }

                return { pps_unstaked: 1.0, pps_staked: 1.0 };
            }

            // Добавляем PPS данные к каждой точке profitData с интерполяцией
            let ppsAvailable = false;
            if (ppsDataSource_wbtc && ppsDataSource_cbbtc && ppsDataSource_tbtc) {
                const ppsArrayWbtc = ppsDataSource_wbtc.data;
                const ppsArrayCbbtc = ppsDataSource_cbbtc.data;
                const ppsArrayTbtc = ppsDataSource_tbtc.data;

                profitData.forEach(point => {
                    point.pps_wbtc = interpolatePPS(point.timestamp, ppsArrayWbtc);
                    point.pps_cbbtc = interpolatePPS(point.timestamp, ppsArrayCbbtc);
                    point.pps_tbtc = interpolatePPS(point.timestamp, ppsArrayTbtc);
                });

                ppsAvailable = true;
                console.log('PPS data interpolated for all markets');
            } else {
                // Если PPS данных нет, используем PPS = 1.0
                profitData.forEach(point => {
                    point.pps_wbtc = { pps_unstaked: 1.0, pps_staked: 1.0 };
                    point.pps_cbbtc = { pps_unstaked: 1.0, pps_staked: 1.0 };
                    point.pps_tbtc = { pps_unstaked: 1.0, pps_staked: 1.0 };
                });
                console.log('PPS data not available, using PPS = 1.0');
            }

            // Функция расчета Fundamental Revenue
            // ПОЛНОСТЬЮ повторяет логику Trading Revenue (учитывая ВСЕ чекбоксы)
            // НО корректирует ТОЛЬКО Withdrawals на Yield Delta процент
            // Формула: (включенный TVL) - (включенные Deposits - Fundamental_Withdrawals) + (включенные Admin_Fees) + (включенный YB)
            // Где Fundamental_Withdrawals = Withdrawals × (1 + Yield_Delta%)
            // Yield_Delta рассчитывается ОДИН РАЗ для последней точки как в index.html
            function calculateFundamentalRevenue(
                includeWbtc = true,
                includeCbbtc = true,
                includeTbtc = true,
                includeWithdrawable = true,
                includeDeposits = true,
                includeWithdrawals = true,
                includeAdminFees = true,
                includeYbEmission = true
            ) {
                if (!ppsAvailable || fullProfitData.length === 0) return fullProfitData.map(d => d.profit);

                // ===== НАЧАЛЬНЫЕ ЗНАЧЕНИЯ PPS ДЛЯ РАСЧЕТА ИСТОРИЧЕСКИХ YIELD DELTA =====
                const firstPoint = fullProfitData[0];

                // Начальные PPS для fundamental returns
                const startPPS_wbtc = firstPoint.pps_wbtc.pps_unstaked;
                const startPPS_cbbtc = firstPoint.pps_cbbtc.pps_unstaked;
                const startPPS_tbtc = firstPoint.pps_tbtc.pps_unstaked;

                // Начальные trading PPS из vaults_yield_data
                const startTradingPPS_wbtc = typeof vaultsYieldData_wbtc !== 'undefined' && vaultsYieldData_wbtc.data.length > 0
                    ? vaultsYieldData_wbtc.data[0].pps_btc : null;
                const startTradingPPS_cbbtc = typeof vaultsYieldData_cbbtc !== 'undefined' && vaultsYieldData_cbbtc.data.length > 0
                    ? vaultsYieldData_cbbtc.data[0].pps_btc : null;
                const startTradingPPS_tbtc = typeof vaultsYieldData_tbtc !== 'undefined' && vaultsYieldData_tbtc.data.length > 0
                    ? vaultsYieldData_tbtc.data[0].pps_btc : null;

                // Создаем lookup для быстрого поиска trading PPS по timestamp
                const tradingPPSLookup_wbtc = new Map();
                const tradingPPSLookup_cbbtc = new Map();
                const tradingPPSLookup_tbtc = new Map();

                if (typeof vaultsYieldData_wbtc !== 'undefined' && vaultsYieldData_wbtc.data) {
                    vaultsYieldData_wbtc.data.forEach(d => tradingPPSLookup_wbtc.set(d.timestamp, d.pps_btc));
                }
                if (typeof vaultsYieldData_cbbtc !== 'undefined' && vaultsYieldData_cbbtc.data) {
                    vaultsYieldData_cbbtc.data.forEach(d => tradingPPSLookup_cbbtc.set(d.timestamp, d.pps_btc));
                }
                if (typeof vaultsYieldData_tbtc !== 'undefined' && vaultsYieldData_tbtc.data) {
                    vaultsYieldData_tbtc.data.forEach(d => tradingPPSLookup_tbtc.set(d.timestamp, d.pps_btc));
                }

                console.log('[Historical Yield Delta Calculation - будет рассчитываться для каждой точки]');

                let cumulativeDeposits = 0;
                let cumulativeWithdrawals = 0;
                let cumulativeAdminFeeWithdrawals = 0;

                // Накопительные withdrawals по рынкам
                let cumulativeWithdrawals_wbtc = 0;
                let cumulativeWithdrawals_cbbtc = 0;
                let cumulativeWithdrawals_tbtc = 0;
                let cumulativeAdminFeeWithdrawals_wbtc = 0;
                let cumulativeAdminFeeWithdrawals_cbbtc = 0;
                let cumulativeAdminFeeWithdrawals_tbtc = 0;

                return fullProfitData.map((point, i) => {
                    const wbtc = fullWbtcData[i];
                    const cbbtc = fullCbbtcData[i];
                    const tbtc = fullTbtcData[i];

                    // ===== РАСЧЕТ YIELD DELTA ДЛЯ ТЕКУЩЕЙ ТОЧКИ =====
                    // Для каждой точки сравниваем returns от начала до этой точки

                    // Fundamental returns (от начала до точки i)
                    const currentPPS_wbtc = point.pps_wbtc.pps_unstaked;
                    const currentPPS_cbbtc = point.pps_cbbtc.pps_unstaked;
                    const currentPPS_tbtc = point.pps_tbtc.pps_unstaked;

                    const fundamentalReturn_wbtc = startPPS_wbtc > 0 ? (currentPPS_wbtc - startPPS_wbtc) / startPPS_wbtc : 0;
                    const fundamentalReturn_cbbtc = startPPS_cbbtc > 0 ? (currentPPS_cbbtc - startPPS_cbbtc) / startPPS_cbbtc : 0;
                    const fundamentalReturn_tbtc = startPPS_tbtc > 0 ? (currentPPS_tbtc - startPPS_tbtc) / startPPS_tbtc : 0;

                    // Trading returns (от начала до точки i) - ищем в vaults_yield_data
                    const currentTradingPPS_wbtc = tradingPPSLookup_wbtc.get(point.timestamp);
                    const currentTradingPPS_cbbtc = tradingPPSLookup_cbbtc.get(point.timestamp);
                    const currentTradingPPS_tbtc = tradingPPSLookup_tbtc.get(point.timestamp);

                    const tradingReturn_wbtc = (startTradingPPS_wbtc && currentTradingPPS_wbtc)
                        ? (currentTradingPPS_wbtc - startTradingPPS_wbtc) / startTradingPPS_wbtc : 0;
                    const tradingReturn_cbbtc = (startTradingPPS_cbbtc && currentTradingPPS_cbbtc)
                        ? (currentTradingPPS_cbbtc - startTradingPPS_cbbtc) / startTradingPPS_cbbtc : 0;
                    const tradingReturn_tbtc = (startTradingPPS_tbtc && currentTradingPPS_tbtc)
                        ? (currentTradingPPS_tbtc - startTradingPPS_tbtc) / startTradingPPS_tbtc : 0;

                    // Yield Delta для этой точки
                    const yieldDelta_wbtc = tradingReturn_wbtc - fundamentalReturn_wbtc;
                    const yieldDelta_cbbtc = tradingReturn_cbbtc - fundamentalReturn_cbbtc;
                    const yieldDelta_tbtc = tradingReturn_tbtc - fundamentalReturn_tbtc;

                    // Fundamental TVL - точная формула через соотношение PPS
                    // Fundamental_TVL = Trading_TVL × (1 + Fundamental_Return) / (1 + Trading_Return)
                    // Это правильно пересчитывает TVL с trading PPS на fundamental PPS
                    let fundamentalTVL = 0;
                    if (includeWbtc) {
                        const trading_tvl_wbtc = wbtc.total_withdrawable_btc || 0;
                        const ratio_wbtc = (1 + tradingReturn_wbtc) !== 0
                            ? (1 + fundamentalReturn_wbtc) / (1 + tradingReturn_wbtc)
                            : 1;
                        fundamentalTVL += trading_tvl_wbtc * ratio_wbtc;
                    }
                    if (includeCbbtc) {
                        const trading_tvl_cbbtc = cbbtc.total_withdrawable_btc || 0;
                        const ratio_cbbtc = (1 + tradingReturn_cbbtc) !== 0
                            ? (1 + fundamentalReturn_cbbtc) / (1 + tradingReturn_cbbtc)
                            : 1;
                        fundamentalTVL += trading_tvl_cbbtc * ratio_cbbtc;
                    }
                    if (includeTbtc) {
                        const trading_tvl_tbtc = tbtc.total_withdrawable_btc || 0;
                        const ratio_tbtc = (1 + tradingReturn_tbtc) !== 0
                            ? (1 + fundamentalReturn_tbtc) / (1 + tradingReturn_tbtc)
                            : 1;
                        fundamentalTVL += trading_tvl_tbtc * ratio_tbtc;
                    }

                    // Накапливаем deposits/withdrawals по рынкам
                    let deposits = 0;
                    let withdrawals = 0;
                    let adminFeeWithdrawals = 0;
                    let adminFees = 0;

                    if (includeWbtc) {
                        deposits += wbtc.deposits_btc || 0;
                        const wbtc_withdrawals = wbtc.withdrawals_btc || 0;
                        const wbtc_adminFeeWithdrawals = currentContractVersion === 'old'
                            ? (wbtc.admin_fees_btc || 0)
                            : (wbtc.admin_fee_withdrawals_btc || 0);

                        cumulativeWithdrawals_wbtc += wbtc_withdrawals;
                        cumulativeAdminFeeWithdrawals_wbtc += wbtc_adminFeeWithdrawals;

                        withdrawals += wbtc_withdrawals;
                        adminFees += wbtc.admin_fees_btc || 0;
                        adminFeeWithdrawals += wbtc_adminFeeWithdrawals;
                    }
                    if (includeCbbtc) {
                        deposits += cbbtc.deposits_btc || 0;
                        const cbbtc_withdrawals = cbbtc.withdrawals_btc || 0;
                        const cbbtc_adminFeeWithdrawals = currentContractVersion === 'old'
                            ? (cbbtc.admin_fees_btc || 0)
                            : (cbbtc.admin_fee_withdrawals_btc || 0);

                        cumulativeWithdrawals_cbbtc += cbbtc_withdrawals;
                        cumulativeAdminFeeWithdrawals_cbbtc += cbbtc_adminFeeWithdrawals;

                        withdrawals += cbbtc_withdrawals;
                        adminFees += cbbtc.admin_fees_btc || 0;
                        adminFeeWithdrawals += cbbtc_adminFeeWithdrawals;
                    }
                    if (includeTbtc) {
                        deposits += tbtc.deposits_btc || 0;
                        const tbtc_withdrawals = tbtc.withdrawals_btc || 0;
                        const tbtc_adminFeeWithdrawals = currentContractVersion === 'old'
                            ? (tbtc.admin_fees_btc || 0)
                            : (tbtc.admin_fee_withdrawals_btc || 0);

                        cumulativeWithdrawals_tbtc += tbtc_withdrawals;
                        cumulativeAdminFeeWithdrawals_tbtc += tbtc_adminFeeWithdrawals;

                        withdrawals += tbtc_withdrawals;
                        adminFees += tbtc.admin_fees_btc || 0;
                        adminFeeWithdrawals += tbtc_adminFeeWithdrawals;
                    }

                    cumulativeDeposits += deposits;
                    cumulativeWithdrawals += withdrawals;
                    cumulativeAdminFeeWithdrawals += adminFeeWithdrawals;

                    // Применяем admin fee withdrawals если checkbox активен
                    const includeAdminFeeWithdrawals = document.getElementById('toggleAdminFeeWithdrawals')?.checked ?? true;

                    // Обычные withdrawals (БЕЗ применения yield delta)
                    const effectiveWithdrawals = includeAdminFeeWithdrawals
                        ? cumulativeWithdrawals + cumulativeAdminFeeWithdrawals
                        : cumulativeWithdrawals;

                    // Fundamental Admin Fees - точная формула через соотношение PPS
                    let fundamentalAdminFees = 0;
                    if (includeWbtc) {
                        const trading_fees_wbtc = wbtc.admin_fees_btc || 0;
                        const fees_to_apply_wbtc = includeAdminFeeWithdrawals
                            ? trading_fees_wbtc + cumulativeAdminFeeWithdrawals_wbtc
                            : trading_fees_wbtc;

                        const ratio_wbtc = (1 + tradingReturn_wbtc) !== 0
                            ? (1 + fundamentalReturn_wbtc) / (1 + tradingReturn_wbtc)
                            : 1;
                        fundamentalAdminFees += fees_to_apply_wbtc * ratio_wbtc;
                    }
                    if (includeCbbtc) {
                        const trading_fees_cbbtc = cbbtc.admin_fees_btc || 0;
                        const fees_to_apply_cbbtc = includeAdminFeeWithdrawals
                            ? trading_fees_cbbtc + cumulativeAdminFeeWithdrawals_cbbtc
                            : trading_fees_cbbtc;

                        const ratio_cbbtc = (1 + tradingReturn_cbbtc) !== 0
                            ? (1 + fundamentalReturn_cbbtc) / (1 + tradingReturn_cbbtc)
                            : 1;
                        fundamentalAdminFees += fees_to_apply_cbbtc * ratio_cbbtc;
                    }
                    if (includeTbtc) {
                        const trading_fees_tbtc = tbtc.admin_fees_btc || 0;
                        const fees_to_apply_tbtc = includeAdminFeeWithdrawals
                            ? trading_fees_tbtc + cumulativeAdminFeeWithdrawals_tbtc
                            : trading_fees_tbtc;

                        const ratio_tbtc = (1 + tradingReturn_tbtc) !== 0
                            ? (1 + fundamentalReturn_tbtc) / (1 + tradingReturn_tbtc)
                            : 1;
                        fundamentalAdminFees += fees_to_apply_tbtc * ratio_tbtc;
                    }

                    // ПОЛНОСТЬЮ повторяем логику зеленой линии с учетом чекбоксов
                    // НО используем fundamental значения (с применением yield delta)
                    let fundamentalRevenue = 0;

                    if (includeWithdrawable) {
                        // Используем FUNDAMENTAL TVL (с yield delta)
                        fundamentalRevenue += fundamentalTVL;
                    }
                    if (includeDeposits) {
                        // Deposits БЕЗ изменений
                        fundamentalRevenue -= cumulativeDeposits;
                    }
                    if (includeWithdrawals) {
                        // Используем обычные withdrawals БЕЗ yield delta
                        fundamentalRevenue += effectiveWithdrawals;
                    }
                    if (includeAdminFees) {
                        // Используем FUNDAMENTAL admin fees (с yield delta)
                        fundamentalRevenue += fundamentalAdminFees;
                    }
                    // Добавляем YB эмиссию с применением yield delta
                    if (includeYbEmission) {
                        if (includeWbtc && point.yb_emission_wbtc_btc) {
                            fundamentalRevenue += point.yb_emission_wbtc_btc * (1 - yieldDelta_wbtc);
                        }
                        if (includeCbbtc && point.yb_emission_cbbtc_btc) {
                            fundamentalRevenue += point.yb_emission_cbbtc_btc * (1 - yieldDelta_cbbtc);
                        }
                        if (includeTbtc && point.yb_emission_tbtc_btc) {
                            fundamentalRevenue += point.yb_emission_tbtc_btc * (1 - yieldDelta_tbtc);
                        }
                    }

                    return fundamentalRevenue;
                });
            }

            // ====== END PPS DATA & FUNDAMENTAL REVENUE CALCULATION ======

            // Хранилище полных данных (нужно для range slider и calculateFundamentalRevenue)
            const fullProfitData = [...profitData];
            const fullWbtcData = [...wbtcData];
            const fullCbbtcData = [...cbbtcData];
            const fullTbtcData = [...tbtcData];

            // Profit Chart
            let profitChart;  // Объявляем переменную заранее
            const datasets = [
                {
                    label: 'Accumulated Revenue (Trading)',
                    data: profitData.map(d => ({x: d.timestamp * 1000, y: d.profit})),
                    borderColor: '#10b981',  // Всегда зеленый
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    stepped: false,
                    spanGaps: true
                },
                {
                    label: 'Fundamental Revenue (PPS-based)',
                    data: calculateFundamentalRevenue().map((y, i) => ({x: profitData[i].timestamp * 1000, y: y})),
                    borderColor: '#8b5cf6',  // Фиолетовый
                    backgroundColor: 'rgba(139, 92, 246, 0.05)',
                    borderWidth: 2,
                    borderDash: [5, 5],  // Пунктирная линия
                    fill: false,
                    tension: 0.4,
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    stepped: false,
                    spanGaps: true,
                    hidden: true  // По умолчанию скрываем
                }
            ];

            profitChart = new Chart(document.getElementById('profitChart'), {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#94a3b8', font: { size: 14 } } },
                        tooltip: {
                            backgroundColor: '#1e293b',
                            titleColor: '#e2e8f0',
                            bodyColor: '#e2e8f0',
                            borderColor: '#334155',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: ctx => {
                                    const index = ctx[0].dataIndex;
                                    const point = profitData[index];
                                    const wbtc = wbtcData[index];

                                    // Форматируем дату и время
                                    const date = new Date(point.timestamp * 1000);
                                    const dateStr = date.toLocaleDateString('en-US');
                                    const timeStr = date.toLocaleTimeString('en-US');

                                    return [
                                        `📅 ${dateStr} ${timeStr}`,
                                        `🔗 Block: ${wbtc.block}`
                                    ];
                                },
                                label: ctx => {
                                    return '';  // Пустая строка, чтобы не было дублирования
                                },
                                afterLabel: ctx => {
                                    const point = profitData[ctx.dataIndex];
                                    const datasetIndex = ctx.datasetIndex;
                                    const netDeposited = point.deposits - point.withdrawals;
                                    const percentOfTVL = (point.profit / finalTVL * 100).toFixed(2);

                                    const lines = [];

                                    // Если это Fundamental Revenue (datasetIndex === 1)
                                    if (datasetIndex === 1 && ppsAvailable) {
                                        const wbtc = wbtcData[ctx.dataIndex];
                                        const cbbtc = cbbtcData[ctx.dataIndex];
                                        const tbtc = tbtcData[ctx.dataIndex];

                                        // Первая точка для расчета изменения PPS
                                        const firstPoint = profitData[0];
                                        const initialPPS_wbtc = firstPoint.pps_wbtc.pps_unstaked;
                                        const initialPPS_cbbtc = firstPoint.pps_cbbtc.pps_unstaked;
                                        const initialPPS_tbtc = firstPoint.pps_tbtc.pps_unstaked;

                                        const initialTVL_wbtc = wbtcData[0].total_withdrawable_btc || 0;
                                        const initialTVL_cbbtc = cbbtcData[0].total_withdrawable_btc || 0;
                                        const initialTVL_tbtc = tbtcData[0].total_withdrawable_btc || 0;

                                        // Fundamental TVL (PPS-based)
                                        const fundamentalTVL_wbtc = initialTVL_wbtc * (point.pps_wbtc.pps_unstaked / initialPPS_wbtc);
                                        const fundamentalTVL_cbbtc = initialTVL_cbbtc * (point.pps_cbbtc.pps_unstaked / initialPPS_cbbtc);
                                        const fundamentalTVL_tbtc = initialTVL_tbtc * (point.pps_tbtc.pps_unstaked / initialPPS_tbtc);
                                        const totalFundamentalTVL = fundamentalTVL_wbtc + fundamentalTVL_cbbtc + fundamentalTVL_tbtc;

                                        lines.push('');
                                        lines.push('📊 FUNDAMENTAL REVENUE (PPS-BASED):');
                                        lines.push('─────────────────────');
                                        lines.push(`Fundamental TVL:      +${totalFundamentalTVL.toFixed(4)} BTC`);
                                        lines.push('  Based on PPS growth:');
                                        lines.push(`  WBTC:  ${fundamentalTVL_wbtc.toFixed(4)} BTC (PPS: ${point.pps_wbtc.pps_unstaked.toFixed(6)})`);
                                        lines.push(`  cbBTC: ${fundamentalTVL_cbbtc.toFixed(4)} BTC (PPS: ${point.pps_cbbtc.pps_unstaked.toFixed(6)})`);
                                        lines.push(`  tBTC:  ${fundamentalTVL_tbtc.toFixed(4)} BTC (PPS: ${point.pps_tbtc.pps_unstaked.toFixed(6)})`);
                                        lines.push(`Net Deposited:        -${netDeposited.toFixed(4)} BTC`);
                                        lines.push(`  (Deposits: ${point.deposits.toFixed(2)} BTC)`);
                                        lines.push(`  (Withdrawals: ${point.withdrawals.toFixed(2)} BTC)`);
                                        lines.push(`Admin Fees:           +${point.admin_fees.toFixed(4)} BTC`);
                                        lines.push('─────────────────────');

                                        const fundamentalRevenue = ctx.parsed.y;

                                        // Реальный TVL
                                        const realTVL = wbtc.total_withdrawable_btc + cbbtc.total_withdrawable_btc + tbtc.total_withdrawable_btc;

                                        // Yield Delta в процентах
                                        const yieldDeltaPercent = totalFundamentalTVL > 0
                                            ? ((realTVL - totalFundamentalTVL) / totalFundamentalTVL) * 100
                                            : 0;

                                        const yieldDeltaBTC = point.profit - fundamentalRevenue;

                                        lines.push(`💰 FUNDAMENTAL REV:   ${fundamentalRevenue.toFixed(4)} BTC`);
                                        lines.push(`📈 Yield Delta:       ${yieldDeltaPercent >= 0 ? '+' : ''}${yieldDeltaPercent.toFixed(4)}%`);
                                        lines.push(`   (${yieldDeltaBTC >= 0 ? '+' : ''}${yieldDeltaBTC.toFixed(4)} BTC)`);
                                        lines.push('');
                                        lines.push('Formula: TVL - (Deposits - Fundamental_Withdrawals) + Admin_Fees');
                                        lines.push('Fundamental_Withdrawals = Withdrawals × (1 + Yield_Delta%)');
                                    } else {
                                        // Trading Revenue (оригинальная логика)
                                        lines.push('');
                                        lines.push('📊 ACCUMULATED REVENUE (TRADING):');
                                        lines.push('─────────────────────');
                                        lines.push(`TVL (available):       +${point.withdrawable.toFixed(4)} BTC`);
                                        lines.push(`Net Deposited:        -${netDeposited.toFixed(4)} BTC`);
                                        lines.push(`  (Deposits: ${point.deposits.toFixed(2)} BTC)`);
                                        lines.push(`  (Withdrawals: ${point.withdrawals.toFixed(2)} BTC)`);
                                        lines.push(`Admin Fees:           +${point.admin_fees.toFixed(4)} BTC`);

                                        // Добавляем YB emission по рынкам если есть
                                        const totalYbEmission = (point.yb_emission_wbtc_btc || 0) +
                                                               (point.yb_emission_cbbtc_btc || 0) +
                                                               (point.yb_emission_tbtc_btc || 0);

                                        if (totalYbEmission > 0) {
                                            lines.push('');
                                            lines.push('YB Emission by Market:');
                                            if (point.yb_emission_wbtc_btc) {
                                                lines.push(`  WBTC:  +${point.yb_emission_wbtc_btc.toFixed(4)} BTC`);
                                            }
                                            if (point.yb_emission_cbbtc_btc) {
                                                lines.push(`  cbBTC: +${point.yb_emission_cbbtc_btc.toFixed(4)} BTC`);
                                            }
                                            if (point.yb_emission_tbtc_btc) {
                                                lines.push(`  tBTC:  +${point.yb_emission_tbtc_btc.toFixed(4)} BTC`);
                                            }
                                            lines.push(`  TOTAL: +${totalYbEmission.toFixed(4)} BTC`);
                                        }

                                        const totalProfit = point.profit + totalYbEmission;

                                        lines.push('─────────────────────');
                                        lines.push(`💰 BALANCE (w/o YB):  ${point.profit.toFixed(4)} BTC (${percentOfTVL}% of TVL)`);

                                        if (totalYbEmission > 0) {
                                            lines.push(`💰 BALANCE (w/ YB):   ${totalProfit.toFixed(4)} BTC`);
                                        }

                                        lines.push('');
                                        lines.push('Formula: TVL - (Deposits - Withdrawals) + Admin Fees + YB');
                                    }

                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM dd'
                                }
                            },
                            ticks: { color: '#64748b' },
                            grid: { color: '#1e293b' }
                        },
                        y: {
                            position: 'left',
                            ticks: { color: '#64748b' },
                            grid: { color: '#1e293b' },
                            title: {
                                display: true,
                                text: 'BTC',
                                color: '#94a3b8'
                            }
                        },
                        y1: {
                            position: 'right',
                            ticks: {
                                color: '#64748b',
                                maxTicksLimit: 10,
                                callback: function(value) {
                                    return value.toFixed(3) + '%';
                                }
                            },
                            grid: { display: false },
                            title: {
                                display: true,
                                text: '% of TVL',
                                color: '#94a3b8'
                            },
                            // Связываем с левой осью через afterDataLimits
                            afterDataLimits: function(axis) {
                                const leftAxis = axis.chart.scales.y;
                                const percentPerBTC = 100 / finalTVL;

                                // Синхронизируем min/max с левой осью
                                axis.min = leftAxis.min * percentPerBTC;
                                axis.max = leftAxis.max * percentPerBTC;
                            }
                        }
                    }
                }
            });

            // TVL by Market Chart
            const tvlByMarketChart = new Chart(document.getElementById('tvlByMarketChart'), {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'WBTC TVL',
                            data: wbtcData.map((d, i) => ({x: profitData[i].timestamp * 1000, y: d.total_withdrawable_btc})),
                            borderColor: '#f97316',
                            backgroundColor: 'rgba(249, 115, 22, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        },
                        {
                            label: 'cbBTC TVL',
                            data: cbbtcData.map((d, i) => ({x: profitData[i].timestamp * 1000, y: d.total_withdrawable_btc})),
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        },
                        {
                            label: 'tBTC TVL',
                            data: tbtcData.map((d, i) => ({x: profitData[i].timestamp * 1000, y: d.total_withdrawable_btc})),
                            borderColor: '#8b5cf6',
                            backgroundColor: 'rgba(139, 92, 246, 0.1)',
                            borderWidth: 2,
                            fill: false,
                            tension: 0.4,
                            pointRadius: 0,
                            pointHoverRadius: 5
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#94a3b8', font: { size: 14 } } },
                        tooltip: {
                            backgroundColor: '#1e293b',
                            titleColor: '#e2e8f0',
                            bodyColor: '#e2e8f0',
                            borderColor: '#334155',
                            borderWidth: 1,
                            padding: 12,
                            callbacks: {
                                title: ctx => {
                                    const index = ctx[0].dataIndex;
                                    const point = profitData[index];
                                    const wbtc = wbtcData[index];

                                    // Форматируем дату и время
                                    const date = new Date(point.timestamp * 1000);
                                    const dateStr = date.toLocaleDateString('en-US');
                                    const timeStr = date.toLocaleTimeString('en-US');

                                    return [
                                        `📅 ${dateStr} ${timeStr}`,
                                        `🔗 Block: ${wbtc.block}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM dd'
                                }
                            },
                            ticks: { color: '#64748b' },
                            grid: { color: '#1e293b' }
                        },
                        y: { beginAtZero: true, ticks: { color: '#64748b' }, grid: { color: '#1e293b' } }
                    }
                }
            });

            // ====== RANGE SLIDER LOGIC ======

            let currentRangeStart = 0;
            let currentRangeEnd = fullProfitData.length - 1;

            // Обновление визуального ползунка
            function updateSliderUI() {
                const rangeStart = document.getElementById('rangeStart');
                const rangeEnd = document.getElementById('rangeEnd');
                const rangeFill = document.getElementById('rangeFill');
                const startLabel = document.getElementById('startLabel');
                const endLabel = document.getElementById('endLabel');

                const startPercent = (parseInt(rangeStart.value) / parseInt(rangeStart.max)) * 100;
                const endPercent = (parseInt(rangeEnd.value) / parseInt(rangeEnd.max)) * 100;

                rangeFill.style.left = startPercent + '%';
                rangeFill.style.width = (endPercent - startPercent) + '%';

                // Обновляем метки
                const startDate = new Date(fullProfitData[currentRangeStart].timestamp * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const endDate = new Date(fullProfitData[currentRangeEnd].timestamp * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

                startLabel.textContent = startDate;
                endLabel.textContent = endDate;
            }

            // Фильтрация данных по диапазону (без пересчета)
            function filterDataByRange() {
                profitData.length = 0;
                wbtcData.length = 0;
                cbbtcData.length = 0;
                tbtcData.length = 0;

                for (let i = currentRangeStart; i <= currentRangeEnd; i++) {
                    profitData.push(fullProfitData[i]);
                    wbtcData.push(fullWbtcData[i]);
                    cbbtcData.push(fullCbbtcData[i]);
                    tbtcData.push(fullTbtcData[i]);
                }

                // Обновляем графики БЕЗ пересчета (просто меняем диапазон)
                updateChartsRange();
            }

            // Обработчики ползунков
            document.getElementById('rangeStart').addEventListener('input', function() {
                let startValue = parseInt(this.value);
                let endValue = parseInt(document.getElementById('rangeEnd').value);

                if (startValue >= endValue) {
                    startValue = endValue - 1;
                    this.value = startValue;
                }

                currentRangeStart = Math.floor((startValue / 100) * (fullProfitData.length - 1));
                updateSliderUI();
            });

            document.getElementById('rangeEnd').addEventListener('input', function() {
                let startValue = parseInt(document.getElementById('rangeStart').value);
                let endValue = parseInt(this.value);

                if (endValue <= startValue) {
                    endValue = startValue + 1;
                    this.value = endValue;
                }

                currentRangeEnd = Math.floor((endValue / 100) * (fullProfitData.length - 1));
                updateSliderUI();
            });

            document.getElementById('rangeStart').addEventListener('change', filterDataByRange);
            document.getElementById('rangeEnd').addEventListener('change', filterDataByRange);

            // Обработчики кнопок периодов
            document.querySelectorAll('.period-button').forEach(button => {
                button.addEventListener('click', function() {
                    // Убираем active со всех кнопок
                    document.querySelectorAll('.period-button').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');

                    const days = this.getAttribute('data-days');

                    if (days === 'all') {
                        currentRangeStart = 0;
                        currentRangeEnd = fullProfitData.length - 1;
                    } else {
                        const daysNum = parseInt(days);
                        currentRangeEnd = fullProfitData.length - 1;

                        // Ищем точку N дней назад
                        const endTimestamp = fullProfitData[currentRangeEnd].timestamp;
                        const targetTimestamp = endTimestamp - (daysNum * 86400);

                        currentRangeStart = fullProfitData.findIndex(p => p.timestamp >= targetTimestamp);
                        if (currentRangeStart === -1) currentRangeStart = 0;
                    }

                    // Обновляем ползунки
                    const startPercent = (currentRangeStart / (fullProfitData.length - 1)) * 100;
                    const endPercent = (currentRangeEnd / (fullProfitData.length - 1)) * 100;

                    document.getElementById('rangeStart').value = startPercent;
                    document.getElementById('rangeEnd').value = endPercent;

                    updateSliderUI();
                    filterDataByRange();
                });
            });

            // Инициализация ползунка
            updateSliderUI();

            // Хранилище рассчитанных данных для ВСЕГО диапазона
            let fullRecalculatedData = null;

            // Функция обновления графиков БЕЗ пересчета (только изменение диапазона)
            function updateChartsRange() {
                // Берем нужный диапазон из уже рассчитанных данных
                if (fullRecalculatedData) {
                    const rangeData = fullRecalculatedData.slice(currentRangeStart, currentRangeEnd + 1);
                    profitChart.data.datasets[0].data = profitData.map((d, i) => ({
                        x: d.timestamp * 1000,
                        y: rangeData[i]
                    }));
                } else {
                    // Если еще не рассчитывали - используем исходные данные
                    profitChart.data.datasets[0].data = profitData.map(d => ({
                        x: d.timestamp * 1000,
                        y: d.profit
                    }));
                }

                // Обновляем финальное значение
                const lastData = profitChart.data.datasets[0].data[profitChart.data.datasets[0].data.length - 1];
                document.getElementById('finalProfit').textContent = lastData.y.toFixed(8) + ' BTC';

                profitChart.update();

                // Обновляем TVL график
                tvlByMarketChart.data.datasets[0].data = wbtcData.map((d, i) => ({
                    x: profitData[i].timestamp * 1000,
                    y: d.total_withdrawable_btc
                }));
                tvlByMarketChart.data.datasets[1].data = cbbtcData.map((d, i) => ({
                    x: profitData[i].timestamp * 1000,
                    y: d.total_withdrawable_btc
                }));
                tvlByMarketChart.data.datasets[2].data = tbtcData.map((d, i) => ({
                    x: profitData[i].timestamp * 1000,
                    y: d.total_withdrawable_btc
                }));
                tvlByMarketChart.update();
            }

            // Функция обновления всех графиков С пересчетом (при изменении чекбоксов)
            function updateAllCharts() {
                // Вызываем updateChart для пересчета с чекбоксами
                updateChart();
            }

            // ====== END RANGE SLIDER LOGIC ======

            // Функция обновления графика на основе чекбоксов
            function updateChart() {
                const includeWithdrawable = document.getElementById('toggleWithdrawable').checked;
                const includeDeposits = document.getElementById('toggleDeposits').checked;
                const includeWithdrawals = document.getElementById('toggleWithdrawals').checked;
                const includeAdminFees = document.getElementById('toggleAdminFees').checked;
                const includeYbEmission = document.getElementById('toggleYbEmission').checked;

                // Выбранные рынки
                const includeWbtc = document.getElementById('toggleWbtc').checked;
                const includeCbbtc = document.getElementById('toggleCbbtc').checked;
                const includeTbtc = document.getElementById('toggleTbtc').checked;

                // Пересчитываем профит для ВСЕХ данных (не только текущего диапазона)
                let cumulativeDeposits = 0;
                let cumulativeWithdrawals = 0;
                let cumulativeAdminFeeWithdrawals = 0;

                fullRecalculatedData = fullProfitData.map((point, i) => {
                    const wbtc = fullWbtcData[i];
                    const cbbtc = fullCbbtcData[i];
                    const tbtc = fullTbtcData[i];

                    // Суммируем только выбранные рынки
                    let withdrawable = 0;
                    let deposits = 0;
                    let withdrawals = 0;
                    let adminFees = 0;
                    let adminFeeWithdrawals = 0;

                    if (includeWbtc) {
                        withdrawable += wbtc.total_withdrawable_btc || 0;
                        deposits += wbtc.deposits_btc || 0;
                        withdrawals += wbtc.withdrawals_btc || 0;
                        adminFees += wbtc.admin_fees_btc || 0;
                        adminFeeWithdrawals += currentContractVersion === 'old' 
                            ? (wbtc.admin_fees_btc || 0) 
                            : (wbtc.admin_fee_withdrawals_btc || 0);
                    }
                    if (includeCbbtc) {
                        withdrawable += cbbtc.total_withdrawable_btc || 0;
                        deposits += cbbtc.deposits_btc || 0;
                        withdrawals += cbbtc.withdrawals_btc || 0;
                        adminFees += cbbtc.admin_fees_btc || 0;
                        adminFeeWithdrawals += currentContractVersion === 'old' 
                            ? (cbbtc.admin_fees_btc || 0) 
                            : (cbbtc.admin_fee_withdrawals_btc || 0);
                    }
                    if (includeTbtc) {
                        withdrawable += tbtc.total_withdrawable_btc || 0;
                        deposits += tbtc.deposits_btc || 0;
                        withdrawals += tbtc.withdrawals_btc || 0;
                        adminFees += tbtc.admin_fees_btc || 0;
                        adminFeeWithdrawals += currentContractVersion === 'old' 
                            ? (tbtc.admin_fees_btc || 0) 
                            : (tbtc.admin_fee_withdrawals_btc || 0);
                    }

                    // Накапливаем депозиты/выводы
                    cumulativeDeposits += deposits;
                    cumulativeWithdrawals += withdrawals;
                    cumulativeAdminFeeWithdrawals += adminFeeWithdrawals;

                    // Вычисляем баланс на основе выбранных компонентов
                    let profit = 0;

                    if (includeWithdrawable) {
                        profit += withdrawable;
                    }
                    if (includeDeposits) {
                        profit -= cumulativeDeposits;
                    }
                    // Обработка admin fee withdrawals (независимо от других галочек)
                    const includeAdminFeeWithdrawals = document.getElementById('toggleAdminFeeWithdrawals')?.checked ?? true;
                    let adminFeeWithdrawalsAdded = false;

                    if (includeWithdrawals) {
                        const effectiveWithdrawals = includeAdminFeeWithdrawals
                            ? cumulativeWithdrawals + cumulativeAdminFeeWithdrawals
                            : cumulativeWithdrawals;
                        profit += effectiveWithdrawals;
                        if (includeAdminFeeWithdrawals) {
                            adminFeeWithdrawalsAdded = true;
                        }
                    }

                    if (includeAdminFees) {
                        const effectiveAdminFees = includeAdminFeeWithdrawals
                            ? adminFees + cumulativeAdminFeeWithdrawals
                            : adminFees;
                        profit += effectiveAdminFees;
                        if (includeAdminFeeWithdrawals) {
                            adminFeeWithdrawalsAdded = true;
                        }
                    }

                    // Если admin fee withdrawals включены, но они еще не были добавлены ни через withdrawals, ни через admin fees
                    if (includeAdminFeeWithdrawals && !adminFeeWithdrawalsAdded) {
                        profit += cumulativeAdminFeeWithdrawals;
                    }

                    // Добавляем YB эмиссию по рынкам если галочка активна
                    if (includeYbEmission) {
                        if (includeWbtc && point.yb_emission_wbtc_btc) {
                            profit += point.yb_emission_wbtc_btc;
                        }
                        if (includeCbbtc && point.yb_emission_cbbtc_btc) {
                            profit += point.yb_emission_cbbtc_btc;
                        }
                        if (includeTbtc && point.yb_emission_tbtc_btc) {
                            profit += point.yb_emission_tbtc_btc;
                        }
                    }

                    return profit;
                });

                // Применяем текущий диапазон к рассчитанным данным
                const rangeData = fullRecalculatedData.slice(currentRangeStart, currentRangeEnd + 1);

                // Обновляем данные графика с timestamps
                profitChart.data.datasets[0].data = profitData.map((d, i) => ({
                    x: d.timestamp * 1000,
                    y: rangeData[i]
                }));

                // Цвет всегда зеленый - это баланс протокола, не профит/убыток
                profitChart.data.datasets[0].borderColor = '#10b981';
                profitChart.data.datasets[0].backgroundColor = 'rgba(16, 185, 129, 0.1)';

                // Обновляем финальное значение в заголовке
                const finalValue = rangeData[rangeData.length - 1];
                document.getElementById('finalProfit').textContent = finalValue.toFixed(8) + ' BTC';
                document.getElementById('answerBox').className = 'answer';  // Всегда зеленый

                // Обновляем Fundamental Revenue линию (dataset index 1)
                if (ppsAvailable && profitChart.data.datasets.length > 1) {
                    const fundamentalRevenueData = calculateFundamentalRevenue(
                        includeWbtc,
                        includeCbbtc,
                        includeTbtc,
                        includeWithdrawable,
                        includeDeposits,
                        includeWithdrawals,
                        includeAdminFees,
                        includeYbEmission
                    );
                    const fundamentalRangeData = fundamentalRevenueData.slice(currentRangeStart, currentRangeEnd + 1);

                    profitChart.data.datasets[1].data = profitData.map((d, i) => ({
                        x: d.timestamp * 1000,
                        y: fundamentalRangeData[i]
                    }));
                }

                profitChart.update();
            }

            // Функция для обновления метрик и графика при изменении Admin Fee Withdrawals checkbox
            function updateMetricsAndChart() {
                // Пересчитываем profitData
                profitData = recalculateProfitData();

                // Обновляем метрики
                const lastPoint = profitData[profitData.length - 1];
                document.getElementById('finalProfit').textContent = lastPoint.profit.toFixed(8) + ' BTC';

                // Обновляем metrics box
                document.querySelector('#metricsBox .metric-row:nth-child(2) .metric-value').textContent =
                    lastPoint.deposits.toFixed(2) + ' BTC';
                document.querySelector('#metricsBox .metric-row:nth-child(3) .metric-value').textContent =
                    lastPoint.withdrawals.toFixed(2) + ' BTC';
                document.querySelector('#metricsBox .metric-row:nth-child(4) .metric-value').textContent =
                    (lastPoint.deposits - lastPoint.withdrawals).toFixed(2) + ' BTC';
                document.querySelector('#metricsBox .metric-row:nth-child(6) .metric-value').textContent =
                    lastPoint.admin_fee_withdrawals.toFixed(4) + ' BTC';
                
                // Обновляем YB Emission метрику
                if (lastPoint.yb_emission_wbtc_btc !== undefined) {
                    const totalYbEmission = (lastPoint.yb_emission_wbtc_btc || 0) +
                                           (lastPoint.yb_emission_cbbtc_btc || 0) +
                                           (lastPoint.yb_emission_tbtc_btc || 0);
                    document.getElementById('ybEmissionValue').textContent = totalYbEmission.toFixed(4) + ' BTC';
                }

                // Обновляем график
                updateChart();
            }

            // Подключаем чекбоксы к функции обновления
            document.getElementById('toggleWithdrawable').addEventListener('change', updateChart);
            document.getElementById('toggleDeposits').addEventListener('change', updateChart);
            document.getElementById('toggleWithdrawals').addEventListener('change', updateChart);
            document.getElementById('toggleAdminFees').addEventListener('change', updateChart);
            document.getElementById('toggleAdminFeeWithdrawals').addEventListener('change', updateMetricsAndChart);

            // Подключаем галочки рынков
            document.getElementById('toggleWbtc').addEventListener('change', updateChart);
            document.getElementById('toggleCbbtc').addEventListener('change', updateChart);
            document.getElementById('toggleTbtc').addEventListener('change', updateChart);

            // Обработчик для YB emission
            if (ybEmissionDataArray && ybEmissionDataArray.length > 0) {
                document.getElementById('toggleYbEmission').addEventListener('change', updateChart);
                // Вызываем updateChart чтобы добавить YB emission с самого начала
                updateChart();
            } else {
                // Если данных нет, отключаем галочку
                document.getElementById('toggleYbEmission').disabled = true;
                document.getElementById('toggleYbEmission').checked = false;
            }

            // Обработчик для Fundamental Revenue
            document.getElementById('toggleFundamental').addEventListener('change', function() {
                const showFundamental = this.checked;
                // Показываем/скрываем вторую линию графика (dataset index 1)
                profitChart.data.datasets[1].hidden = !showFundamental;
                profitChart.update();
            });

            // Проверяем доступность PPS данных
            if (!ppsAvailable) {
                // Если PPS данных нет, отключаем галочку и скрываем линию
                document.getElementById('toggleFundamental').disabled = true;
                document.getElementById('toggleFundamental').checked = false;
                profitChart.data.datasets[1].hidden = true;
                profitChart.update();
            }

            // Показываем контент
            document.getElementById('loading').style.display = 'none';
            document.getElementById('content').style.display = 'block';

        } catch (error) {
            document.getElementById('loading').innerHTML = `
                <div style="color: #ef4444;">
                    <h2>Error: ${error.message}</h2>
                    <p style="margin-top: 20px; color: #94a3b8;">
                        Run: <code style="background: #1e293b; padding: 5px 10px; border-radius: 4px;">python collect_sync.py</code>
                    </p>
                </div>
            `;
            console.error('Error:', error);
        }
    });
    </script>
</body>
</html>








